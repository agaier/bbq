"""Provides EmitterBase."""
import itertools
from abc import ABC, abstractmethod

import numpy as np
from ribs.emitters._emitter_base import EmitterBase

class EmitterBase(EmitterBase):
    """Base class for emitters in BBQ:

    As vanilla pyribs but with:
    
    -) Pulse: logging of emitter effectiveness in adding and improving solutions
    """

    def __init__(self, archive, solution_dim, bounds):
        EmitterBase.__init__(self, archive, solution_dim, bounds)
        self.pulse = np.zeros((1,3), int) # NOT_ADDED | IMPROVE | NEW

    def tell(self, solutions, objective_values, behavior_values, metadata=None):
        """Inserts entries into the archive.

        This base class implementation (in :class:`~ribs.emitters.EmitterBase`)
        simply inserts entries into the archive by calling
        :meth:`~ribs.archives.ArchiveBase.add`. It is enough for simple emitters
        like :class:`~ribs.emitters.GaussianEmitter`, but more complex emitters
        will almost certainly need to override it.

        Args:
            solutions (numpy.ndarray): Array of solutions generated by this
                emitter's :meth:`ask()` method.
            objective_values (numpy.ndarray): 1D array containing the objective
                function value of each solution.
            behavior_values (numpy.ndarray): ``(n, <behavior space dimension>)``
                array with the behavior space coordinates of each solution.
            metadata (numpy.ndarray): 1D object array containing a metadata
                object for each solution.
        """
        pulse = np.zeros(3) # NOT_ADDED | IMPROVE | NEW
        metadata = itertools.repeat(None) if metadata is None else metadata
        for sol, obj, beh, meta in zip(solutions, objective_values,
                                       behavior_values, metadata):
            status, value = self.archive.add(sol, obj, beh, meta)
            pulse[status] += 1
        self.pulse = np.vstack([self.pulse, pulse])