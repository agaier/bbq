"""Provides MultiContainer EmitterBase."""
import itertools
from abc import ABC, abstractmethod

import numpy as np
from ribs.emitters._emitter_base import EmitterBase

class MC_EmitterBase(EmitterBase):
    """Base class for emitters in BBQ:

    As vanilla pyribs but with:
    
    -) Pulse: logging of emitter effectiveness in adding and improving solutions
    """

    def __init__(self, archive, solution_dim, bounds):
        self._archive = archive
        self._solution_dim = solution_dim
        (self._lower_bounds,
         self._upper_bounds) = self._process_bounds(bounds, self._solution_dim,
                                                    archive.dtype)
        self.pulse = np.zeros((1,3), int) # NOT_ADDED | IMPROVE | NEW

    @property
    def archives(self):
        """ribs.archives.ArchiveBase: The archive which stores solutions
        generated by this emitter."""
        return self._archives

    def tell(self, solutions, objective_values, behavior_values, metadata=None):
        """Inserts entries into the archive.

        This base class implementation (in :class:`~ribs.emitters.EmitterBase`)
        simply inserts entries into the archive by calling
        :meth:`~ribs.archives.ArchiveBase.add`. It is enough for simple emitters
        like :class:`~ribs.emitters.GaussianEmitter`, but more complex emitters
        will almost certainly need to override it.

        Args:
            solutions (numpy.ndarray): Array of solutions generated by this
                emitter's :meth:`ask()` method.
            objective_values (numpy.ndarray): 1D array containing the objective
                function value of each solution.
            behavior_values (numpy.ndarray): ``(n, <behavior space dimension>)``
                array with the behavior space coordinates of each solution.
            metadata (numpy.ndarray): 1D object array containing a metadata
                object for each solution.
        """
        pulse = np.zeros(3) # NOT_ADDED | IMPROVE | NEW
        metadata = itertools.repeat(None) if metadata is None else metadata
        for sol, obj, beh, meta in zip(solutions, objective_values,
                                       behavior_values, metadata):
            for archive in self.archive._archives:       
                chosen_desc = self.archive.chosen_desc(beh, archive)                                
                status, value = archive.add(sol, obj, chosen_desc, meta)
                pulse[status] += 1
        self.pulse = np.vstack([self.pulse, pulse])